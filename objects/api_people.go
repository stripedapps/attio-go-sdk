/*
Attio Standard Objects

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PeopleAPIService PeopleAPI service
type PeopleAPIService service

type ApiV2ObjectsPeopleRecordsPostRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	v2ObjectsPeopleRecordsPutRequest *V2ObjectsPeopleRecordsPutRequest
}

func (r ApiV2ObjectsPeopleRecordsPostRequest) V2ObjectsPeopleRecordsPutRequest(v2ObjectsPeopleRecordsPutRequest V2ObjectsPeopleRecordsPutRequest) ApiV2ObjectsPeopleRecordsPostRequest {
	r.v2ObjectsPeopleRecordsPutRequest = &v2ObjectsPeopleRecordsPutRequest
	return r
}

func (r ApiV2ObjectsPeopleRecordsPostRequest) Execute() (*V2ObjectsPeopleRecordsPost200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsPostExecute(r)
}

/*
V2ObjectsPeopleRecordsPost Create a person Record

Creates a new person Record. This endpoint will throw on conflicts of unique attributes, like `email_addresses`. If you would prefer to update person records on conflicts, please use the Assert person record endpoint instead. Please note, the `avatar_url` attribute cannot currently be set via the API.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ObjectsPeopleRecordsPostRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsPost(ctx context.Context) ApiV2ObjectsPeopleRecordsPostRequest {
	return ApiV2ObjectsPeopleRecordsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsPost200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsPostExecute(r ApiV2ObjectsPeopleRecordsPostRequest) (*V2ObjectsPeopleRecordsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsPeopleRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsPeopleRecordsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsPeopleRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsPutRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	matchingAttribute *string
	v2ObjectsPeopleRecordsPutRequest *V2ObjectsPeopleRecordsPutRequest
}

func (r ApiV2ObjectsPeopleRecordsPutRequest) MatchingAttribute(matchingAttribute string) ApiV2ObjectsPeopleRecordsPutRequest {
	r.matchingAttribute = &matchingAttribute
	return r
}

func (r ApiV2ObjectsPeopleRecordsPutRequest) V2ObjectsPeopleRecordsPutRequest(v2ObjectsPeopleRecordsPutRequest V2ObjectsPeopleRecordsPutRequest) ApiV2ObjectsPeopleRecordsPutRequest {
	r.v2ObjectsPeopleRecordsPutRequest = &v2ObjectsPeopleRecordsPutRequest
	return r
}

func (r ApiV2ObjectsPeopleRecordsPutRequest) Execute() (*V2ObjectsPeopleRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsPutExecute(r)
}

/*
V2ObjectsPeopleRecordsPut Assert a person Record

Use this endpoint to create or update person records, using a unique attribute to search for existing People (for example the `email_addresses` attribute). If a person is found with the same value for the matching attribute, that person will be updated. If no person with the same value for the matching attribute is found, a new person will be created instead. If you would like to avoid matching, please use the Create person endpoint.


If the matching attribute is a multiselect attribute, new values will be added and existing values will not be deleted. For any other multiselect attribute, all values will be either created or deleted as necessary to match the list of supplied values.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ObjectsPeopleRecordsPutRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsPut(ctx context.Context) ApiV2ObjectsPeopleRecordsPutRequest {
	return ApiV2ObjectsPeopleRecordsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsPut200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsPutExecute(r ApiV2ObjectsPeopleRecordsPutRequest) (*V2ObjectsPeopleRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchingAttribute == nil {
		return localVarReturnValue, nil, reportError("matchingAttribute is required and must be specified")
	}
	if r.v2ObjectsPeopleRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsPeopleRecordsPutRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "matching_attribute", r.matchingAttribute, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsPeopleRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsQueryPostRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	v2ObjectsPeopleRecordsQueryPostRequest *V2ObjectsPeopleRecordsQueryPostRequest
}

func (r ApiV2ObjectsPeopleRecordsQueryPostRequest) V2ObjectsPeopleRecordsQueryPostRequest(v2ObjectsPeopleRecordsQueryPostRequest V2ObjectsPeopleRecordsQueryPostRequest) ApiV2ObjectsPeopleRecordsQueryPostRequest {
	r.v2ObjectsPeopleRecordsQueryPostRequest = &v2ObjectsPeopleRecordsQueryPostRequest
	return r
}

func (r ApiV2ObjectsPeopleRecordsQueryPostRequest) Execute() (*V2ObjectsPeopleRecordsQueryPost200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsQueryPostExecute(r)
}

/*
V2ObjectsPeopleRecordsQueryPost List person records 

Lists person records, with the option to filter and sort results.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ObjectsPeopleRecordsQueryPostRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsQueryPost(ctx context.Context) ApiV2ObjectsPeopleRecordsQueryPostRequest {
	return ApiV2ObjectsPeopleRecordsQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsQueryPost200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsQueryPostExecute(r ApiV2ObjectsPeopleRecordsQueryPostRequest) (*V2ObjectsPeopleRecordsQueryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsQueryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsPeopleRecordsQueryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsPeopleRecordsQueryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsPeopleRecordsQueryPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsQueryPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsQueryPost404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	recordId string
	attribute string
	showHistoric *bool
	limit *int32
	offset *int32
}

func (r ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest) ShowHistoric(showHistoric bool) ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.showHistoric = &showHistoric
	return r
}

func (r ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest) Limit(limit int32) ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest) Offset(offset int32) ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest) Execute() (*V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetExecute(r)
}

/*
V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet List person record attribute values

Gets all values for a given attribute on a person Record. If the attribute is historic, this endpoint has the ability to return all historic values using the `show_historic` query param.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @param attribute
 @return ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet(ctx context.Context, recordId string, attribute string) ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest {
	return ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
		attribute: attribute,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetExecute(r ApiV2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGetRequest) (*V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records/{record_id}/attributes/{attribute}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showHistoric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_historic", r.showHistoric, "form", "")
	} else {
		var defaultValue bool = false
		r.showHistoric = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsRecordIdDeleteRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	recordId string
}

func (r ApiV2ObjectsPeopleRecordsRecordIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsRecordIdDeleteExecute(r)
}

/*
V2ObjectsPeopleRecordsRecordIdDelete Delete a person Record

Deletes a single person record by ID.

Required scopes: `object_configuration:read`, `record_permission:read-write`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsPeopleRecordsRecordIdDeleteRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdDelete(ctx context.Context, recordId string) ApiV2ObjectsPeopleRecordsRecordIdDeleteRequest {
	return ApiV2ObjectsPeopleRecordsRecordIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdDeleteExecute(r ApiV2ObjectsPeopleRecordsRecordIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsRecordIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsRecordIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	recordId string
	limit *int32
	offset *int32
}

func (r ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest) Limit(limit int32) ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest) Offset(offset int32) ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest) Execute() (*V2ObjectsPeopleRecordsRecordIdEntriesGet200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsRecordIdEntriesGetExecute(r)
}

/*
V2ObjectsPeopleRecordsRecordIdEntriesGet List person record entries

List all entries, across all lists, for which this person record is the parent.

Required scopes: `record_permission:read`, `object_configuration:read`, `list_entry:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdEntriesGet(ctx context.Context, recordId string) ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest {
	return ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsRecordIdEntriesGet200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdEntriesGetExecute(r ApiV2ObjectsPeopleRecordsRecordIdEntriesGetRequest) (*V2ObjectsPeopleRecordsRecordIdEntriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsRecordIdEntriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsRecordIdEntriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records/{record_id}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsRecordIdGetRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	recordId string
}

func (r ApiV2ObjectsPeopleRecordsRecordIdGetRequest) Execute() (*V2ObjectsPeopleRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsRecordIdGetExecute(r)
}

/*
V2ObjectsPeopleRecordsRecordIdGet Get a person Record

Gets a single person record by its `record_id`.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsPeopleRecordsRecordIdGetRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdGet(ctx context.Context, recordId string) ApiV2ObjectsPeopleRecordsRecordIdGetRequest {
	return ApiV2ObjectsPeopleRecordsRecordIdGetRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsPut200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdGetExecute(r ApiV2ObjectsPeopleRecordsRecordIdGetRequest) (*V2ObjectsPeopleRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsRecordIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsRecordIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsPeopleRecordsRecordIdPatchRequest struct {
	ctx context.Context
	ApiService *PeopleAPIService
	recordId string
	v2ObjectsPeopleRecordsPutRequest *V2ObjectsPeopleRecordsPutRequest
}

func (r ApiV2ObjectsPeopleRecordsRecordIdPatchRequest) V2ObjectsPeopleRecordsPutRequest(v2ObjectsPeopleRecordsPutRequest V2ObjectsPeopleRecordsPutRequest) ApiV2ObjectsPeopleRecordsRecordIdPatchRequest {
	r.v2ObjectsPeopleRecordsPutRequest = &v2ObjectsPeopleRecordsPutRequest
	return r
}

func (r ApiV2ObjectsPeopleRecordsRecordIdPatchRequest) Execute() (*V2ObjectsPeopleRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsPeopleRecordsRecordIdPatchExecute(r)
}

/*
V2ObjectsPeopleRecordsRecordIdPatch Update a person Record

Use this endpoint to update person records by `record_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the [Assert person endpoint](/reference/put_v2-objects-people-records) to overwrite or remove multiselect attribute values. Please note, the `avatar_url` attribute cannot currently be updated via the API.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsPeopleRecordsRecordIdPatchRequest
*/
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdPatch(ctx context.Context, recordId string) ApiV2ObjectsPeopleRecordsRecordIdPatchRequest {
	return ApiV2ObjectsPeopleRecordsRecordIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsPut200Response
func (a *PeopleAPIService) V2ObjectsPeopleRecordsRecordIdPatchExecute(r ApiV2ObjectsPeopleRecordsRecordIdPatchRequest) (*V2ObjectsPeopleRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeopleAPIService.V2ObjectsPeopleRecordsRecordIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/people/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsPeopleRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsPeopleRecordsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsPeopleRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsRecordIdPatch400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
