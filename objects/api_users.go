/*
Attio Standard Objects

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// UsersAPIService UsersAPI service
type UsersAPIService service

type ApiV2ObjectsUsersRecordsPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	v2ObjectsUsersRecordsPutRequest *V2ObjectsUsersRecordsPutRequest
}

func (r ApiV2ObjectsUsersRecordsPostRequest) V2ObjectsUsersRecordsPutRequest(v2ObjectsUsersRecordsPutRequest V2ObjectsUsersRecordsPutRequest) ApiV2ObjectsUsersRecordsPostRequest {
	r.v2ObjectsUsersRecordsPutRequest = &v2ObjectsUsersRecordsPutRequest
	return r
}

func (r ApiV2ObjectsUsersRecordsPostRequest) Execute() (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsPostExecute(r)
}

/*
V2ObjectsUsersRecordsPost Create a user record

Creates a new user record. This endpoint will throw on conflicts of unique attributes, like `primary_email_address`. If you would prefer to update user records on conflicts, please use the Assert user record endpoint instead. Please note, the `avatar_url` attribute cannot currently be set via the API.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ObjectsUsersRecordsPostRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsPost(ctx context.Context) ApiV2ObjectsUsersRecordsPostRequest {
	return ApiV2ObjectsUsersRecordsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ObjectsUsersRecordsPut200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsPostExecute(r ApiV2ObjectsUsersRecordsPostRequest) (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsUsersRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsUsersRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsUsersRecordsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsUsersRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsPutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	matchingAttribute *string
	v2ObjectsUsersRecordsPutRequest *V2ObjectsUsersRecordsPutRequest
}

func (r ApiV2ObjectsUsersRecordsPutRequest) MatchingAttribute(matchingAttribute string) ApiV2ObjectsUsersRecordsPutRequest {
	r.matchingAttribute = &matchingAttribute
	return r
}

func (r ApiV2ObjectsUsersRecordsPutRequest) V2ObjectsUsersRecordsPutRequest(v2ObjectsUsersRecordsPutRequest V2ObjectsUsersRecordsPutRequest) ApiV2ObjectsUsersRecordsPutRequest {
	r.v2ObjectsUsersRecordsPutRequest = &v2ObjectsUsersRecordsPutRequest
	return r
}

func (r ApiV2ObjectsUsersRecordsPutRequest) Execute() (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsPutExecute(r)
}

/*
V2ObjectsUsersRecordsPut Assert a user record

Use this endpoint to create or update user records, using a unique attribute to search for existing users (for example the `primary_email_address` attribute). If a user is found with the same value for the matching attribute, that user will be updated, otherwise a new user will be created instead. If the matching attribute is a multiselect attribute, new values will be added and existing values will not be deleted. For any other multiselect attribute, all values will be either created or deleted as necessary to match the list of supplied values.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ObjectsUsersRecordsPutRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsPut(ctx context.Context) ApiV2ObjectsUsersRecordsPutRequest {
	return ApiV2ObjectsUsersRecordsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ObjectsUsersRecordsPut200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsPutExecute(r ApiV2ObjectsUsersRecordsPutRequest) (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsUsersRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchingAttribute == nil {
		return localVarReturnValue, nil, reportError("matchingAttribute is required and must be specified")
	}
	if r.v2ObjectsUsersRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsUsersRecordsPutRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "matching_attribute", r.matchingAttribute, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsUsersRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsQueryPostRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	v2ObjectsUsersRecordsQueryPostRequest *V2ObjectsUsersRecordsQueryPostRequest
}

func (r ApiV2ObjectsUsersRecordsQueryPostRequest) V2ObjectsUsersRecordsQueryPostRequest(v2ObjectsUsersRecordsQueryPostRequest V2ObjectsUsersRecordsQueryPostRequest) ApiV2ObjectsUsersRecordsQueryPostRequest {
	r.v2ObjectsUsersRecordsQueryPostRequest = &v2ObjectsUsersRecordsQueryPostRequest
	return r
}

func (r ApiV2ObjectsUsersRecordsQueryPostRequest) Execute() (*V2ObjectsUsersRecordsQueryPost200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsQueryPostExecute(r)
}

/*
V2ObjectsUsersRecordsQueryPost List user records

Lists user records, with the option to filter and sort results.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ObjectsUsersRecordsQueryPostRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsQueryPost(ctx context.Context) ApiV2ObjectsUsersRecordsQueryPostRequest {
	return ApiV2ObjectsUsersRecordsQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ObjectsUsersRecordsQueryPost200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsQueryPostExecute(r ApiV2ObjectsUsersRecordsQueryPostRequest) (*V2ObjectsUsersRecordsQueryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsUsersRecordsQueryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsUsersRecordsQueryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsUsersRecordsQueryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsUsersRecordsQueryPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsQueryPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsQueryPost404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	recordId string
	attribute string
	showHistoric *bool
	limit *int32
	offset *int32
}

func (r ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest) ShowHistoric(showHistoric bool) ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.showHistoric = &showHistoric
	return r
}

func (r ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest) Limit(limit int32) ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest) Offset(offset int32) ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest) Execute() (*V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetExecute(r)
}

/*
V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet List user record attribute values

Gets all values for a given attribute on a user record. If the attribute is historic, this endpoint has the ability to return all historic values using the `show_historic` query param.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @param attribute
 @return ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet(ctx context.Context, recordId string, attribute string) ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest {
	return ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
		attribute: attribute,
	}
}

// Execute executes the request
//  @return V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetExecute(r ApiV2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGetRequest) (*V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsRecordIdAttributesAttributeValuesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records/{record_id}/attributes/{attribute}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showHistoric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_historic", r.showHistoric, "form", "")
	} else {
		var defaultValue bool = false
		r.showHistoric = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsRecordIdAttributesAttributeValuesGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsRecordIdDeleteRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	recordId string
}

func (r ApiV2ObjectsUsersRecordsRecordIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsRecordIdDeleteExecute(r)
}

/*
V2ObjectsUsersRecordsRecordIdDelete Delete a user record

Deletes a single user record by ID.

Required scopes: `object_configuration:read`, `record_permission:read-write`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsUsersRecordsRecordIdDeleteRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdDelete(ctx context.Context, recordId string) ApiV2ObjectsUsersRecordsRecordIdDeleteRequest {
	return ApiV2ObjectsUsersRecordsRecordIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdDeleteExecute(r ApiV2ObjectsUsersRecordsRecordIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsRecordIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsRecordIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	recordId string
	limit *int32
	offset *int32
}

func (r ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest) Limit(limit int32) ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest) Offset(offset int32) ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest) Execute() (*V2ObjectsPeopleRecordsRecordIdEntriesGet200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsRecordIdEntriesGetExecute(r)
}

/*
V2ObjectsUsersRecordsRecordIdEntriesGet List user record entries

List all entries, across all lists, for which this user record is the parent.

Required scopes: `record_permission:read`, `object_configuration:read`, `list_entry:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdEntriesGet(ctx context.Context, recordId string) ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest {
	return ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsPeopleRecordsRecordIdEntriesGet200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdEntriesGetExecute(r ApiV2ObjectsUsersRecordsRecordIdEntriesGetRequest) (*V2ObjectsPeopleRecordsRecordIdEntriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsPeopleRecordsRecordIdEntriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsRecordIdEntriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records/{record_id}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsRecordIdGetRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	recordId string
}

func (r ApiV2ObjectsUsersRecordsRecordIdGetRequest) Execute() (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsRecordIdGetExecute(r)
}

/*
V2ObjectsUsersRecordsRecordIdGet Get a user record

Gets a single user record by its `record_id`.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsUsersRecordsRecordIdGetRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdGet(ctx context.Context, recordId string) ApiV2ObjectsUsersRecordsRecordIdGetRequest {
	return ApiV2ObjectsUsersRecordsRecordIdGetRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsUsersRecordsPut200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdGetExecute(r ApiV2ObjectsUsersRecordsRecordIdGetRequest) (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsUsersRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsRecordIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsRecordIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsUsersRecordsRecordIdPatchRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	recordId string
	v2ObjectsUsersRecordsPutRequest *V2ObjectsUsersRecordsPutRequest
}

func (r ApiV2ObjectsUsersRecordsRecordIdPatchRequest) V2ObjectsUsersRecordsPutRequest(v2ObjectsUsersRecordsPutRequest V2ObjectsUsersRecordsPutRequest) ApiV2ObjectsUsersRecordsRecordIdPatchRequest {
	r.v2ObjectsUsersRecordsPutRequest = &v2ObjectsUsersRecordsPutRequest
	return r
}

func (r ApiV2ObjectsUsersRecordsRecordIdPatchRequest) Execute() (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsUsersRecordsRecordIdPatchExecute(r)
}

/*
V2ObjectsUsersRecordsRecordIdPatch Update a user Record

Use this endpoint to update user records by `record_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the [Assert user endpoint](/reference/put_v2-objects-users-records) to overwrite or remove multiselect attribute values. Please note, the `avatar_url` attribute cannot currently be updated via the API.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordId
 @return ApiV2ObjectsUsersRecordsRecordIdPatchRequest
*/
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdPatch(ctx context.Context, recordId string) ApiV2ObjectsUsersRecordsRecordIdPatchRequest {
	return ApiV2ObjectsUsersRecordsRecordIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsUsersRecordsPut200Response
func (a *UsersAPIService) V2ObjectsUsersRecordsRecordIdPatchExecute(r ApiV2ObjectsUsersRecordsRecordIdPatchRequest) (*V2ObjectsUsersRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsUsersRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.V2ObjectsUsersRecordsRecordIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/users/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsUsersRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsUsersRecordsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsUsersRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsPeopleRecordsRecordIdPatch400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsPeopleRecordsPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
