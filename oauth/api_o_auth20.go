/*
Attio OAuth flow

Welcome to the Attio OAuth flow documentation. All of the OAuth APIs are documented here.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// OAuth20APIService OAuth20API service
type OAuth20APIService service

type ApiAuthorizeGetRequest struct {
	ctx context.Context
	ApiService *OAuth20APIService
	clientId *string
	responseType *string
	redirectUri *string
	state *string
}

func (r ApiAuthorizeGetRequest) ClientId(clientId string) ApiAuthorizeGetRequest {
	r.clientId = &clientId
	return r
}

func (r ApiAuthorizeGetRequest) ResponseType(responseType string) ApiAuthorizeGetRequest {
	r.responseType = &responseType
	return r
}

func (r ApiAuthorizeGetRequest) RedirectUri(redirectUri string) ApiAuthorizeGetRequest {
	r.redirectUri = &redirectUri
	return r
}

func (r ApiAuthorizeGetRequest) State(state string) ApiAuthorizeGetRequest {
	r.state = &state
	return r
}

func (r ApiAuthorizeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuthorizeGetExecute(r)
}

/*
AuthorizeGet Authorize Endpoint

Use open source libraries to perform OAuth 2.0. You can find a list of libraries here: https://oauth.net/code/

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizeGetRequest
*/
func (a *OAuth20APIService) AuthorizeGet(ctx context.Context) ApiAuthorizeGetRequest {
	return ApiAuthorizeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OAuth20APIService) AuthorizeGetExecute(r ApiAuthorizeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OAuth20APIService.AuthorizeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return nil, reportError("clientId is required and must be specified")
	}
	if r.responseType == nil {
		return nil, reportError("responseType is required and must be specified")
	}
	if r.redirectUri == nil {
		return nil, reportError("redirectUri is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "response_type", r.responseType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "redirect_uri", r.redirectUri, "form", "")
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 302 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOauthIntrospectPostRequest struct {
	ctx context.Context
	ApiService *OAuth20APIService
	token *string
}

func (r ApiOauthIntrospectPostRequest) Token(token string) ApiOauthIntrospectPostRequest {
	r.token = &token
	return r
}

func (r ApiOauthIntrospectPostRequest) Execute() (*OauthIntrospectPost200Response, *http.Response, error) {
	return r.ApiService.OauthIntrospectPostExecute(r)
}

/*
OauthIntrospectPost Introspect Endpoint

Check whether an access token is valid, and if so, what scopes and identity it grants

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOauthIntrospectPostRequest
*/
func (a *OAuth20APIService) OauthIntrospectPost(ctx context.Context) ApiOauthIntrospectPostRequest {
	return ApiOauthIntrospectPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OauthIntrospectPost200Response
func (a *OAuth20APIService) OauthIntrospectPostExecute(r ApiOauthIntrospectPostRequest) (*OauthIntrospectPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OauthIntrospectPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OAuth20APIService.OauthIntrospectPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/introspect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "token", r.token, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOauthTokenPostRequest struct {
	ctx context.Context
	ApiService *OAuth20APIService
	clientId *string
	clientSecret *string
	grantType *string
	code *string
}

// The client ID of your integration (this can be found in your integration settings page).
func (r ApiOauthTokenPostRequest) ClientId(clientId string) ApiOauthTokenPostRequest {
	r.clientId = &clientId
	return r
}

// The client secret of your integration (this can be found in your integration settings page).
func (r ApiOauthTokenPostRequest) ClientSecret(clientSecret string) ApiOauthTokenPostRequest {
	r.clientSecret = &clientSecret
	return r
}

// The grant type. This should always be &#x60;authorization_code&#x60;.
func (r ApiOauthTokenPostRequest) GrantType(grantType string) ApiOauthTokenPostRequest {
	r.grantType = &grantType
	return r
}

// The code which you received after redirecting from the &#x60;/authorize&#x60; endpoint.
func (r ApiOauthTokenPostRequest) Code(code string) ApiOauthTokenPostRequest {
	r.code = &code
	return r
}

func (r ApiOauthTokenPostRequest) Execute() (*OauthTokenPost200Response, *http.Response, error) {
	return r.ApiService.OauthTokenPostExecute(r)
}

/*
OauthTokenPost Token Endpoint

Use open source libraries to perform OAuth 2.0. You can find a list of libraries here: https://oauth.net/code/

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOauthTokenPostRequest
*/
func (a *OAuth20APIService) OauthTokenPost(ctx context.Context) ApiOauthTokenPostRequest {
	return ApiOauthTokenPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OauthTokenPost200Response
func (a *OAuth20APIService) OauthTokenPostExecute(r ApiOauthTokenPostRequest) (*OauthTokenPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OauthTokenPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OAuth20APIService.OauthTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.clientSecret == nil {
		return localVarReturnValue, nil, reportError("clientSecret is required and must be specified")
	}
	if r.grantType == nil {
		return localVarReturnValue, nil, reportError("grantType is required and must be specified")
	}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "client_id", r.clientId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "client_secret", r.clientSecret, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "grant_type", r.grantType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "code", r.code, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
