/*
Attio API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
Contact: support@attio.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RecordsAPIService RecordsAPI service
type RecordsAPIService service

type ApiV2ObjectsObjectRecordsPostRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	v2ObjectsObjectRecordsPostRequest *V2ObjectsObjectRecordsPostRequest
}

func (r ApiV2ObjectsObjectRecordsPostRequest) V2ObjectsObjectRecordsPostRequest(v2ObjectsObjectRecordsPostRequest V2ObjectsObjectRecordsPostRequest) ApiV2ObjectsObjectRecordsPostRequest {
	r.v2ObjectsObjectRecordsPostRequest = &v2ObjectsObjectRecordsPostRequest
	return r
}

func (r ApiV2ObjectsObjectRecordsPostRequest) Execute() (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsPostExecute(r)
}

/*
V2ObjectsObjectRecordsPost Create a record

Creates a new person, company or other record. This endpoint will throw on conflicts of unique attributes. If you would prefer to update records on conflicts, please use the [Assert record endpoint](/reference/put_v2-objects-object-records) instead.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @return ApiV2ObjectsObjectRecordsPostRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsPost(ctx context.Context, object string) ApiV2ObjectsObjectRecordsPostRequest {
	return ApiV2ObjectsObjectRecordsPostRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsPut200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsPostExecute(r ApiV2ObjectsObjectRecordsPostRequest) (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsObjectRecordsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsObjectRecordsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsObjectRecordsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsObjectRecordsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsObjectGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsPutRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	matchingAttribute *string
	v2ObjectsObjectRecordsPutRequest *V2ObjectsObjectRecordsPutRequest
}

func (r ApiV2ObjectsObjectRecordsPutRequest) MatchingAttribute(matchingAttribute string) ApiV2ObjectsObjectRecordsPutRequest {
	r.matchingAttribute = &matchingAttribute
	return r
}

func (r ApiV2ObjectsObjectRecordsPutRequest) V2ObjectsObjectRecordsPutRequest(v2ObjectsObjectRecordsPutRequest V2ObjectsObjectRecordsPutRequest) ApiV2ObjectsObjectRecordsPutRequest {
	r.v2ObjectsObjectRecordsPutRequest = &v2ObjectsObjectRecordsPutRequest
	return r
}

func (r ApiV2ObjectsObjectRecordsPutRequest) Execute() (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsPutExecute(r)
}

/*
V2ObjectsObjectRecordsPut Assert a record

Use this endpoint to create or update people, companies and other records. A matching attribute is used to search for existing records. If a record is found with the same value for the matching attribute, that record will be updated. If no record with the same value for the matching attribute is found, a new record will be created instead. If you would like to avoid matching, please use the [Create record endpoint](/reference/post_v2-objects-object-records).

If the matching attribute is a multiselect attribute, new values will be added and existing values will not be deleted. For any other multiselect attribute, all values will be either created or deleted as necessary to match the list of supplied values.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @return ApiV2ObjectsObjectRecordsPutRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsPut(ctx context.Context, object string) ApiV2ObjectsObjectRecordsPutRequest {
	return ApiV2ObjectsObjectRecordsPutRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsPut200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsPutExecute(r ApiV2ObjectsObjectRecordsPutRequest) (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchingAttribute == nil {
		return localVarReturnValue, nil, reportError("matchingAttribute is required and must be specified")
	}
	if r.v2ObjectsObjectRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsObjectRecordsPutRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "matching_attribute", r.matchingAttribute, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsObjectRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsObjectRecordsPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsObjectGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsQueryPostRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	v2ObjectsObjectRecordsQueryPostRequest *V2ObjectsObjectRecordsQueryPostRequest
}

func (r ApiV2ObjectsObjectRecordsQueryPostRequest) V2ObjectsObjectRecordsQueryPostRequest(v2ObjectsObjectRecordsQueryPostRequest V2ObjectsObjectRecordsQueryPostRequest) ApiV2ObjectsObjectRecordsQueryPostRequest {
	r.v2ObjectsObjectRecordsQueryPostRequest = &v2ObjectsObjectRecordsQueryPostRequest
	return r
}

func (r ApiV2ObjectsObjectRecordsQueryPostRequest) Execute() (*V2ObjectsObjectRecordsQueryPost200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsQueryPostExecute(r)
}

/*
V2ObjectsObjectRecordsQueryPost List records

Lists people, company or other records, with the option to filter and sort results.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @return ApiV2ObjectsObjectRecordsQueryPostRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsQueryPost(ctx context.Context, object string) ApiV2ObjectsObjectRecordsQueryPostRequest {
	return ApiV2ObjectsObjectRecordsQueryPostRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsQueryPost200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsQueryPostExecute(r ApiV2ObjectsObjectRecordsQueryPostRequest) (*V2ObjectsObjectRecordsQueryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsQueryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records/query"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsObjectRecordsQueryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsObjectRecordsQueryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsObjectRecordsQueryPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsObjectRecordsQueryPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsObjectRecordsQueryPost404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	recordId string
	attribute string
	showHistoric *bool
	limit *int32
	offset *int32
}

func (r ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest) ShowHistoric(showHistoric bool) ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.showHistoric = &showHistoric
	return r
}

func (r ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest) Limit(limit int32) ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest) Offset(offset int32) ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest) Execute() (*V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetExecute(r)
}

/*
V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet List record attribute values

Gets all values for a given attribute on a record. If the attribute is historic, this endpoint has the ability to return all historic values using the `show_historic` query param.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @param recordId
 @param attribute
 @return ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet(ctx context.Context, object string, recordId string, attribute string) ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest {
	return ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
		recordId: recordId,
		attribute: attribute,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetExecute(r ApiV2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetRequest) (*V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records/{record_id}/attributes/{attribute}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showHistoric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_historic", r.showHistoric, "form", "")
	} else {
		var defaultValue bool = false
		r.showHistoric = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2TargetIdentifierAttributesAttributeGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsRecordIdDeleteRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	recordId string
}

func (r ApiV2ObjectsObjectRecordsRecordIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsRecordIdDeleteExecute(r)
}

/*
V2ObjectsObjectRecordsRecordIdDelete Delete a record

Deletes a single record (e.g. a company or person) by ID.

Required scopes: `object_configuration:read`, `record_permission:read-write`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @param recordId
 @return ApiV2ObjectsObjectRecordsRecordIdDeleteRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdDelete(ctx context.Context, object string, recordId string) ApiV2ObjectsObjectRecordsRecordIdDeleteRequest {
	return ApiV2ObjectsObjectRecordsRecordIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdDeleteExecute(r ApiV2ObjectsObjectRecordsRecordIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsRecordIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsObjectRecordsRecordIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	recordId string
	limit *int32
	offset *int32
}

func (r ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest) Limit(limit int32) ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest) Offset(offset int32) ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest) Execute() (*V2ObjectsObjectRecordsRecordIdEntriesGet200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsRecordIdEntriesGetExecute(r)
}

/*
V2ObjectsObjectRecordsRecordIdEntriesGet List record entries

List all entries, across all lists, for which this record is the parent.

Required scopes: `record_permission:read`, `object_configuration:read`, `list_entry:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @param recordId
 @return ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdEntriesGet(ctx context.Context, object string, recordId string) ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest {
	return ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsRecordIdEntriesGet200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdEntriesGetExecute(r ApiV2ObjectsObjectRecordsRecordIdEntriesGetRequest) (*V2ObjectsObjectRecordsRecordIdEntriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsRecordIdEntriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsRecordIdEntriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records/{record_id}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsRecordIdGetRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	recordId string
}

func (r ApiV2ObjectsObjectRecordsRecordIdGetRequest) Execute() (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsRecordIdGetExecute(r)
}

/*
V2ObjectsObjectRecordsRecordIdGet Get a record

Gets a single person, company or other record by its `record_id`.

Required scopes: `record_permission:read`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @param recordId
 @return ApiV2ObjectsObjectRecordsRecordIdGetRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdGet(ctx context.Context, object string, recordId string) ApiV2ObjectsObjectRecordsRecordIdGetRequest {
	return ApiV2ObjectsObjectRecordsRecordIdGetRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsPut200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdGetExecute(r ApiV2ObjectsObjectRecordsRecordIdGetRequest) (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsRecordIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsObjectRecordsRecordIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ObjectsObjectRecordsRecordIdPatchRequest struct {
	ctx context.Context
	ApiService *RecordsAPIService
	object string
	recordId string
	v2ObjectsObjectRecordsPutRequest *V2ObjectsObjectRecordsPutRequest
}

func (r ApiV2ObjectsObjectRecordsRecordIdPatchRequest) V2ObjectsObjectRecordsPutRequest(v2ObjectsObjectRecordsPutRequest V2ObjectsObjectRecordsPutRequest) ApiV2ObjectsObjectRecordsRecordIdPatchRequest {
	r.v2ObjectsObjectRecordsPutRequest = &v2ObjectsObjectRecordsPutRequest
	return r
}

func (r ApiV2ObjectsObjectRecordsRecordIdPatchRequest) Execute() (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	return r.ApiService.V2ObjectsObjectRecordsRecordIdPatchExecute(r)
}

/*
V2ObjectsObjectRecordsRecordIdPatch Update a record

Use this endpoint to update people, companies and other records by `record_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the [Assert record endpoint](/reference/put_v2-objects-object-records) to overwrite or remove multiselect attribute values.

Required scopes: `record_permission:read-write`, `object_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param object
 @param recordId
 @return ApiV2ObjectsObjectRecordsRecordIdPatchRequest
*/
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdPatch(ctx context.Context, object string, recordId string) ApiV2ObjectsObjectRecordsRecordIdPatchRequest {
	return ApiV2ObjectsObjectRecordsRecordIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		object: object,
		recordId: recordId,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsPut200Response
func (a *RecordsAPIService) V2ObjectsObjectRecordsRecordIdPatchExecute(r ApiV2ObjectsObjectRecordsRecordIdPatchRequest) (*V2ObjectsObjectRecordsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecordsAPIService.V2ObjectsObjectRecordsRecordIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/objects/{object}/records/{record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object"+"}", url.PathEscape(parameterValueToString(r.object, "object")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"record_id"+"}", url.PathEscape(parameterValueToString(r.recordId, "recordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsObjectRecordsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsObjectRecordsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsObjectRecordsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsObjectRecordsRecordIdPatch400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ObjectsObjectGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
