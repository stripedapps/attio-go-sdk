/*
Attio API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
Contact: support@attio.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EntriesAPIService EntriesAPI service
type EntriesAPIService service

type ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	entryId string
	attribute string
	showHistoric *bool
	limit *int32
	offset *int32
}

func (r ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest) ShowHistoric(showHistoric bool) ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest {
	r.showHistoric = &showHistoric
	return r
}

func (r ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest) Limit(limit int32) ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest) Offset(offset int32) ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest) Execute() (*V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesEntryIdAttributesAttributeValuesGetExecute(r)
}

/*
V2ListsListEntriesEntryIdAttributesAttributeValuesGet List attribute values for a list entry

Gets all values for a given attribute on a list entry. If the attribute is historic, this endpoint has the ability to return all historic values using the `show_historic` query param.

Required scopes: `list_entry:read`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @param entryId
 @param attribute
 @return ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesEntryIdAttributesAttributeValuesGet(ctx context.Context, list string, entryId string, attribute string) ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest {
	return ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
		entryId: entryId,
		attribute: attribute,
	}
}

// Execute executes the request
//  @return V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response
func (a *EntriesAPIService) V2ListsListEntriesEntryIdAttributesAttributeValuesGetExecute(r ApiV2ListsListEntriesEntryIdAttributesAttributeValuesGetRequest) (*V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesEntryIdAttributesAttributeValuesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries/{entry_id}/attributes/{attribute}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterValueToString(r.entryId, "entryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attribute"+"}", url.PathEscape(parameterValueToString(r.attribute, "attribute")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showHistoric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_historic", r.showHistoric, "form", "")
	} else {
		var defaultValue bool = false
		r.showHistoric = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesEntryIdDeleteRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	entryId string
}

func (r ApiV2ListsListEntriesEntryIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesEntryIdDeleteExecute(r)
}

/*
V2ListsListEntriesEntryIdDelete Delete a list entry

Deletes a single list entry by its `entry_id`.

Required scopes: `list_entry:read-write`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @param entryId
 @return ApiV2ListsListEntriesEntryIdDeleteRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesEntryIdDelete(ctx context.Context, list string, entryId string) ApiV2ListsListEntriesEntryIdDeleteRequest {
	return ApiV2ListsListEntriesEntryIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EntriesAPIService) V2ListsListEntriesEntryIdDeleteExecute(r ApiV2ListsListEntriesEntryIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesEntryIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries/{entry_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterValueToString(r.entryId, "entryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesEntryIdGetRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	entryId string
}

func (r ApiV2ListsListEntriesEntryIdGetRequest) Execute() (*V2ListsListEntriesPut200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesEntryIdGetExecute(r)
}

/*
V2ListsListEntriesEntryIdGet Get a list entry

Gets a single list entry by its `entry_id`.

Required scopes: `list_entry:read`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @param entryId
 @return ApiV2ListsListEntriesEntryIdGetRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesEntryIdGet(ctx context.Context, list string, entryId string) ApiV2ListsListEntriesEntryIdGetRequest {
	return ApiV2ListsListEntriesEntryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return V2ListsListEntriesPut200Response
func (a *EntriesAPIService) V2ListsListEntriesEntryIdGetExecute(r ApiV2ListsListEntriesEntryIdGetRequest) (*V2ListsListEntriesPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ListsListEntriesPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesEntryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries/{entry_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterValueToString(r.entryId, "entryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesEntryIdPatchRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	entryId string
	v2ListsListEntriesEntryIdPutRequest *V2ListsListEntriesEntryIdPutRequest
}

func (r ApiV2ListsListEntriesEntryIdPatchRequest) V2ListsListEntriesEntryIdPutRequest(v2ListsListEntriesEntryIdPutRequest V2ListsListEntriesEntryIdPutRequest) ApiV2ListsListEntriesEntryIdPatchRequest {
	r.v2ListsListEntriesEntryIdPutRequest = &v2ListsListEntriesEntryIdPutRequest
	return r
}

func (r ApiV2ListsListEntriesEntryIdPatchRequest) Execute() (*V2ListsListEntriesPut200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesEntryIdPatchExecute(r)
}

/*
V2ListsListEntriesEntryIdPatch Update a list entry (append multiselect values)

Use this endpoint to update list entries by `entry_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the `PUT` endpoint to overwrite or remove multiselect attribute values.

Required scopes: `list_entry:read-write`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @param entryId
 @return ApiV2ListsListEntriesEntryIdPatchRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesEntryIdPatch(ctx context.Context, list string, entryId string) ApiV2ListsListEntriesEntryIdPatchRequest {
	return ApiV2ListsListEntriesEntryIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return V2ListsListEntriesPut200Response
func (a *EntriesAPIService) V2ListsListEntriesEntryIdPatchExecute(r ApiV2ListsListEntriesEntryIdPatchRequest) (*V2ListsListEntriesPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ListsListEntriesPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesEntryIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries/{entry_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterValueToString(r.entryId, "entryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ListsListEntriesEntryIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ListsListEntriesEntryIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ListsListEntriesEntryIdPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ListsListEntriesEntryIdPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesEntryIdPutRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	entryId string
	v2ListsListEntriesEntryIdPutRequest *V2ListsListEntriesEntryIdPutRequest
}

func (r ApiV2ListsListEntriesEntryIdPutRequest) V2ListsListEntriesEntryIdPutRequest(v2ListsListEntriesEntryIdPutRequest V2ListsListEntriesEntryIdPutRequest) ApiV2ListsListEntriesEntryIdPutRequest {
	r.v2ListsListEntriesEntryIdPutRequest = &v2ListsListEntriesEntryIdPutRequest
	return r
}

func (r ApiV2ListsListEntriesEntryIdPutRequest) Execute() (*V2ListsListEntriesPut200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesEntryIdPutExecute(r)
}

/*
V2ListsListEntriesEntryIdPut Update a list entry (overwrite multiselect values)

Use this endpoint to update list entries by `entry_id`. If the update payload includes multiselect attributes, the values supplied will overwrite/remove the list of values that already exist (if any). Use the `PATCH` endpoint to add multiselect attribute values without removing those value that already exist.

Required scopes: `list_entry:read-write`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @param entryId
 @return ApiV2ListsListEntriesEntryIdPutRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesEntryIdPut(ctx context.Context, list string, entryId string) ApiV2ListsListEntriesEntryIdPutRequest {
	return ApiV2ListsListEntriesEntryIdPutRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return V2ListsListEntriesPut200Response
func (a *EntriesAPIService) V2ListsListEntriesEntryIdPutExecute(r ApiV2ListsListEntriesEntryIdPutRequest) (*V2ListsListEntriesPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ListsListEntriesPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesEntryIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries/{entry_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterValueToString(r.entryId, "entryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ListsListEntriesEntryIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ListsListEntriesEntryIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ListsListEntriesEntryIdPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ListsListEntriesEntryIdPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesPostRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	v2ListsListEntriesPutRequest *V2ListsListEntriesPutRequest
}

func (r ApiV2ListsListEntriesPostRequest) V2ListsListEntriesPutRequest(v2ListsListEntriesPutRequest V2ListsListEntriesPutRequest) ApiV2ListsListEntriesPostRequest {
	r.v2ListsListEntriesPutRequest = &v2ListsListEntriesPutRequest
	return r
}

func (r ApiV2ListsListEntriesPostRequest) Execute() (*V2ListsListEntriesPut200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesPostExecute(r)
}

/*
V2ListsListEntriesPost Create an entry (add record to list)

Adds a record to a list as a new list entry. This endpoint will throw on conflicts of unique attributes. Multiple list entries are allowed for the same parent record

Required scopes: `list_entry:read-write`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @return ApiV2ListsListEntriesPostRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesPost(ctx context.Context, list string) ApiV2ListsListEntriesPostRequest {
	return ApiV2ListsListEntriesPostRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
	}
}

// Execute executes the request
//  @return V2ListsListEntriesPut200Response
func (a *EntriesAPIService) V2ListsListEntriesPostExecute(r ApiV2ListsListEntriesPostRequest) (*V2ListsListEntriesPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ListsListEntriesPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ListsListEntriesPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ListsListEntriesPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ListsListEntriesPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ListsListEntriesPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListEntriesPost404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesPutRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	v2ListsListEntriesPutRequest *V2ListsListEntriesPutRequest
}

func (r ApiV2ListsListEntriesPutRequest) V2ListsListEntriesPutRequest(v2ListsListEntriesPutRequest V2ListsListEntriesPutRequest) ApiV2ListsListEntriesPutRequest {
	r.v2ListsListEntriesPutRequest = &v2ListsListEntriesPutRequest
	return r
}

func (r ApiV2ListsListEntriesPutRequest) Execute() (*V2ListsListEntriesPut200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesPutExecute(r)
}

/*
V2ListsListEntriesPut Assert a list entry by parent

Use this endpoint to create or update a list entry for a given parent record. If an entry with the specified parent record is found, that entry will be updated. If no such entry is found, a new entry will be created instead. If there are multiple entries with the same parent record, this endpoint with return the "MULTIPLE_MATCH_RESULTS" error. When writing to multi-select attributes, all values will be either created or deleted as necessary to match the list of values supplied in the request body.

Required scopes: `list_entry:read-write`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @return ApiV2ListsListEntriesPutRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesPut(ctx context.Context, list string) ApiV2ListsListEntriesPutRequest {
	return ApiV2ListsListEntriesPutRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
	}
}

// Execute executes the request
//  @return V2ListsListEntriesPut200Response
func (a *EntriesAPIService) V2ListsListEntriesPutExecute(r ApiV2ListsListEntriesPutRequest) (*V2ListsListEntriesPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ListsListEntriesPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ListsListEntriesPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2ListsListEntriesPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ListsListEntriesPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2ListsListEntriesPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListEntriesPut404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ListsListEntriesQueryPostRequest struct {
	ctx context.Context
	ApiService *EntriesAPIService
	list string
	v2ObjectsObjectRecordsQueryPostRequest *V2ObjectsObjectRecordsQueryPostRequest
}

func (r ApiV2ListsListEntriesQueryPostRequest) V2ObjectsObjectRecordsQueryPostRequest(v2ObjectsObjectRecordsQueryPostRequest V2ObjectsObjectRecordsQueryPostRequest) ApiV2ListsListEntriesQueryPostRequest {
	r.v2ObjectsObjectRecordsQueryPostRequest = &v2ObjectsObjectRecordsQueryPostRequest
	return r
}

func (r ApiV2ListsListEntriesQueryPostRequest) Execute() (*V2ListsListEntriesQueryPost200Response, *http.Response, error) {
	return r.ApiService.V2ListsListEntriesQueryPostExecute(r)
}

/*
V2ListsListEntriesQueryPost List entries

Lists entries in a given list, with the option to filter and sort results.

Required scopes: `list_entry:read`, `list_configuration:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param list
 @return ApiV2ListsListEntriesQueryPostRequest
*/
func (a *EntriesAPIService) V2ListsListEntriesQueryPost(ctx context.Context, list string) ApiV2ListsListEntriesQueryPostRequest {
	return ApiV2ListsListEntriesQueryPostRequest{
		ApiService: a,
		ctx: ctx,
		list: list,
	}
}

// Execute executes the request
//  @return V2ListsListEntriesQueryPost200Response
func (a *EntriesAPIService) V2ListsListEntriesQueryPostExecute(r ApiV2ListsListEntriesQueryPostRequest) (*V2ListsListEntriesQueryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ListsListEntriesQueryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesAPIService.V2ListsListEntriesQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/lists/{list}/entries/query"
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterValueToString(r.list, "list")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2ObjectsObjectRecordsQueryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ObjectsObjectRecordsQueryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2ObjectsObjectRecordsQueryPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2ListsListGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
